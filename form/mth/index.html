<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.7.32">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="author" content="Serguei Sokol (TBI)">
<meta name="author" content="Pierre Millard (TBI)">

<title>influx_si tutorial JS MetaboHub 15-17/10/2025</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="index_files/libs/clipboard/clipboard.min.js"></script>
<script src="index_files/libs/quarto-html/quarto.js" type="module"></script>
<script src="index_files/libs/quarto-html/tabsets/tabsets.js" type="module"></script>
<script src="index_files/libs/quarto-html/popper.min.js"></script>
<script src="index_files/libs/quarto-html/tippy.umd.min.js"></script>
<script src="index_files/libs/quarto-html/anchor.min.js"></script>
<link href="index_files/libs/quarto-html/tippy.css" rel="stylesheet">
<link href="index_files/libs/quarto-html/quarto-syntax-highlighting-37eea08aefeeee20ff55810ff984fec1.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="index_files/libs/bootstrap/bootstrap.min.js"></script>
<link href="index_files/libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="index_files/libs/bootstrap/bootstrap-84dc821d013ac5f9dc9c845995ce9d81.min.css" rel="stylesheet" append-hash="true" id="quarto-bootstrap" data-mode="light">


</head>

<body class="fullcontent quarto-light">

<div id="quarto-content" class="page-columns page-rows-contents page-layout-article">

<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title"><code>influx_si</code> tutorial<br>JS <a href="https://www.metabohub.fr/">MetaboHub</a> 15-17/10/2025</h1>
</div>



<div class="quarto-title-meta">

    <div>
    <div class="quarto-title-meta-heading">Authors</div>
    <div class="quarto-title-meta-contents">
             <p>Serguei Sokol (TBI) </p>
             <p>Pierre Millard (TBI) </p>
          </div>
  </div>
    
  
    
  </div>
  


</header>


<p>This tutorial support can be found at <a href="https://mathscell.github.io/form/mth/" class="uri">https://mathscell.github.io/form/mth/</a></p>
<p><img src="images/qrmth.svg" class="img-fluid"></p>
<section id="introduction-to-influx_si" class="level1">
<h1>Introduction to <code>influx_si</code></h1>
<p><code>influx_si</code> can be used to estimate metabolic fluxes and concentrations in metabolically stationary mode using two different labeling regimes:</p>
<ul>
<li>stationary labeling =&gt; <code>influx_s</code></li>
<li>instationary labeling =&gt; <code>influx_i</code> The term <code>influx_si</code> is used when a affirmation applies to both regimes.</li>
</ul>
<section id="the-goals-of-this-tutorial" class="level2">
<h2 class="anchored" data-anchor-id="the-goals-of-this-tutorial">The goals of this tutorial</h2>
<p>We’ll try to:</p>
<ul>
<li>create a calculation case for <code>influx_i</code> <em>ab initio</em> for a simple metabolic network;</li>
<li>simulate measurement data;</li>
<li>and estimate fluxes and concentrations.</li>
</ul>
</section>
<section id="prerequisites" class="level2">
<h2 class="anchored" data-anchor-id="prerequisites">Prerequisites</h2>
<section id="conda-installation" class="level3">
<h3 class="anchored" data-anchor-id="conda-installation">Conda installation</h3>
<p>If not yet done, install miniconda from <a href="https://www.anaconda.com/docs/getting-started/miniconda/install">download page</a> E.g. on windows you can do:</p>
<pre><code>$ curl https://repo.anaconda.com/miniconda/Miniconda3-latest-Windows-x86_64.exe -o .\miniconda.exe
$ start /wait "" .\miniconda.exe /S
$ del .\miniconda.exe</code></pre>
<p>Now we configure our conda installation by removing the channel <code>defaults</code> and adding <code>bioconda</code> and <code>conda-forge</code>.</p>
<pre><code>conda config --remove channels defaults
conda config --add channels bioconda
conda config --add channels conda-forge
# check the result
conda config --show channels</code></pre>
</section>
<section id="influx_si-installation" class="level3">
<h3 class="anchored" data-anchor-id="influx_si-installation"><code>influx_si</code> installation</h3>
<p>Open “Anaconda promt” from Windows menu.</p>
<p>In conda terminal, create new environment for this tutorial</p>
<pre><code>$ conda create -n tuto influx_si
$ conda activate tuto</code></pre>
<p>Yous should see <code>(tuto)</code> in a prompt now. Let check <code>influx_si</code>’s version:</p>
<pre><code>$ influx_s --v</code></pre>
<p>Should show <code>7.4.1</code>. If not, run:</p>
<pre><code>$ conda install influx_si=7.4.1</code></pre>
<p>Let further check if R libraries can be loaded without problem:</p>
<pre><code>R -e "library(arrApply)"</code></pre>
<p>should execute without error.</p>
<p>⚠️ If failed, you can try in conda:</p>
<pre><code>influx_s --install_rdep

# re-check installation
R -e "library(arrApply)"</code></pre>
</section>
</section>
<section id="network-to-simulate" class="level2">
<h2 class="anchored" data-anchor-id="network-to-simulate">Network to simulate</h2>
<div class="quarto-figure quarto-figure-left">
<figure class="figure">
<p><img src="tuto.svg" class="img-fluid quarto-figure quarto-figure-left figure-img" style="width:10cm"></p>
</figure>
</div>
<p>Metabolites <code>A</code> and <code>B</code> are the internal metabolites, <code>A_in</code> is the input, <code>B_out</code> is the output metabolites. They are not participating in balance equations as they can be consumed/accumulated. Only internal metabolites are considered as stationary and participate in mass and label balance. The reaction <code>r_1</code> is a reversible reaction between <code>A</code> and <code>B</code>. It means that the exchange flux <code>r_1.xch</code> can be non 0. Reactions <code>r_in</code> and <code>r_out</code> are the input and output reactions, respectively. The fluxes of these reactions are not reversible, i.e.&nbsp;their exchange fluxes are 0. This is mandatory. Otherwise, a terminal internal metabolite would be considered as “dead-end”, i.e.&nbsp;the net flux is 0 but the exchange flux is not.</p>
</section>
<section id="creating-first-file-tuto.netw" class="level2">
<h2 class="anchored" data-anchor-id="creating-first-file-tuto.netw">Creating first file <code>tuto.netw</code></h2>
<p>Create a directory <code>tuto</code> where all our work (input files and results) will reside:</p>
<pre><code>$ mkdir tuto
$ cd tuto</code></pre>
<p><code>influx_si</code> relies on MTF (Multiple TSV Files) input format. It includes several files, each providing a particular type of information. The central one – the network file with extension <code>.netw</code>.</p>
<p>Edit file <code>tuto.netw</code> in <a href="https://notepad-plus-plus.org/downloads/" title="plain text editor">Notepad++</a> or alike editor to have the following content:</p>
<pre><code>r_in:  A_in (a) -&gt; A (a)
r_1:   A (a) &lt;-&gt; B (a)
r_out: B (a) -&gt; B_out (a)</code></pre>
<p>Note that the separator between reaction name and its content “:” can be replaced by an invisible tabulation character that we note later as <code>&lt;tab&gt;</code>.</p>
<p>Our network with carbon transitions is ready! Let try to use it:</p>
<pre class="shell"><code>$ influx_i --pref tuto</code></pre>
<p>It ends up in error but at this stage it is normal: we are lacking many things for a working example :</p>
<ul>
<li><p>input labeling configuration (<code>.linp</code> file) -&gt; we have to edit it;</p></li>
<li><p>measured isotopic data (<code>.miso</code>) -&gt; we have to collect (here simulate) data;</p></li>
<li><p>possibly measured input/output fluxes (<code>.mflux</code>) -&gt; here, not used;</p></li>
<li><p>possibly measured metabolite concentrations <code>(.mmet</code>) -&gt; here, not used;</p></li>
<li><p>possibly fine tuning of tarting point and flux/metabolite types (<code>.tvar</code>) -&gt; here, we’ll change a starting value of a free flux.</p></li>
<li><p>possible constraints on fluxes and metabolite concentrations (<code>.cnstr</code>) -&gt; here, not used</p></li>
<li><p>and finally, a file with different options to configure optimization/simulation processes (<code>.opt</code>) -&gt; here, we’ll set up different options.</p></li>
</ul>
<p>But first of all, let visually check if our <code>.netw</code> file corresponds to our intentions:</p>
<pre class="shell"><code>$ ftbl2html --pref tuto</code></pre>
<p>Open <code>tuto.html</code> in a browser.</p>
<p>It should look like a previous diagram. But in real life, there may be some problems:</p>
<ul>
<li><p>syntax errors;</p></li>
<li><p>different omissions or typos, errors in reaction types (reversible/not reversible);</p></li>
<li><p>metabolite type (output/dead-end)…</p></li>
</ul>
<p>Check error messages and network diagram to correct possible problems.</p>
</section>
<section id="prepare-other-mtf-files" class="level2">
<h2 class="anchored" data-anchor-id="prepare-other-mtf-files">Prepare other MTF files</h2>
<p>Copy <code>tuto.linp.def</code> to <code>tuto.linp</code>. By default, all input metabolites are configured to be fully labeled. Let leave it as is for this tutorial.</p>
<p>Edit <code>.miso</code> file to indicate what are metabolites that will be measured for isotopic data (each column is separated by a <code>&lt;tab&gt;</code> character):</p>
<table class="table-striped table-hover caption-top table">
<caption>Content of <code>tuto.miso</code> file</caption>
<thead>
<tr class="header">
<th>Specie</th>
<th>Fragment</th>
<th>Dataset</th>
<th>Isospecies</th>
<th>Value</th>
<th>SD</th>
<th>Time</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>A</td>
<td></td>
<td>MS-A</td>
<td>M0</td>
<td>NA</td>
<td>0.002</td>
<td></td>
</tr>
<tr class="even">
<td>A</td>
<td></td>
<td>MS-A</td>
<td>M1</td>
<td>NA</td>
<td>0.002</td>
<td></td>
</tr>
<tr class="odd">
<td>B</td>
<td></td>
<td>MS-B</td>
<td>M0</td>
<td>NA</td>
<td>0.002</td>
<td></td>
</tr>
<tr class="even">
<td>B</td>
<td></td>
<td>MS-B</td>
<td>M1</td>
<td>NA</td>
<td>0.002</td>
<td></td>
</tr>
</tbody>
</table>
<p>Text editor can be a sub-optimal tool for checking a good column alignment. You can use an HTML page <a href="http://mathscell.github.io/vtsv.html" class="uri">http://mathscell.github.io/vtsv.html</a> to check it (drag&amp;drop works with this page).</p>
<p>Let edit <code>tuto.opt</code> to tell <code>influx_i</code>:</p>
<ul>
<li><p>to run a simulation from time 0 to 10 with 5 time points (which will correspond to sample collection in a real experiment) (<code>tmax=10, dt=2</code>)</p></li>
<li><p>but subdivide each time interval into 4 sub-intervals for smoother curve simulation (<code>nsubdiv_dt=4</code>)</p></li>
<li><p>moreover, we want just a simulation (not flux estimations; i.e.&nbsp;no optimization) (<code>--noopt</code>)</p></li>
<li><p>with a second order of approximation error (<code>--time_order=2</code>)</p></li>
<li><p>generate PDF with simulated labeling dynamics (<code>posttreat_R=plot_ilab.R</code>)</p></li>
<li><p>as the simulation will be used later as a substitute for measured data, we ask to add artificial noise to get more realistic in submitted data during flux estimations. (<code>--addnoise --seed 777</code>)</p></li>
</ul>
<p>It gives:</p>
<table class="table-striped table-hover caption-top table">
<caption>Content of <code>tuto.opt</code> file</caption>
<colgroup>
<col style="width: 20%">
<col style="width: 79%">
</colgroup>
<thead>
<tr class="header">
<th>Name</th>
<th>Value</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>tmax</code></td>
<td><code>10</code></td>
</tr>
<tr class="even">
<td><code>dt</code></td>
<td><code>2</code></td>
</tr>
<tr class="odd">
<td><code>nsubdiv_dt</code></td>
<td><code>4</code></td>
</tr>
<tr class="even">
<td><code>commandArgs</code></td>
<td><code>--noscale --time_order=2 --noopt --addnoise --seed 777</code></td>
</tr>
<tr class="odd">
<td><code>posttreat_R</code></td>
<td><code>plot_ilab.R</code></td>
</tr>
</tbody>
</table>
</section>
<section id="running-first-simulation" class="level2">
<h2 class="anchored" data-anchor-id="running-first-simulation">Running first simulation</h2>
<p>Now, <code>influx_i</code> should run without errors:</p>
<pre class="shell"><code>influx_i --pref tuto</code></pre>
<p>Let see the plots in <code>tuto_res/tmp/tuto.pdf</code> file. The curve should be increasing for M1 and decreasing for M0. They should be sharper for A metabolite as it is closer to the entry than B.</p>
</section>
<section id="using-simulated-data-as-measurements" class="level2">
<h2 class="anchored" data-anchor-id="using-simulated-data-as-measurements">Using simulated data as measurements</h2>
<p>Backup <code>tuto.miso</code> in <code>tuto.miso.save</code> and copy <code>tuto_res/tuto.miso.sim</code> to <code>tuto.miso</code>.</p>
<p>Now, rerunning <code>influx_i</code> produce PDF with simulated (smooth lines) and “measured” (dots with broken lines) data. They are perfectly aligned because we have used for starting point the same flux and metabolite values as for measurement simulation. Let change the starting point 0.2 for <code>r_out</code> in <code>.tvar</code> file by 0.1 (first, rename <code>tuto.tvar.def</code> to <code>tuto.tvar</code>):</p>
<pre><code>r_in NET F 0.2     -&gt;      r_in NET F 0.1</code></pre>
<p>After running <code>influx_i</code>, in the PDF, we can see a significant difference between simulated and measured data. It makes sens now to run flux estimation by suppressing <code>--noopt</code>, <code>--addnoise</code> and <code>--seed 777</code> in <code>tuto.opt</code> file.</p>
<p>Running <code>influx_i</code> again and taking a look at <code>tuto_res/tuto.log</code>, we can see that flux estimation was done in 5 iterations (may slightly vary in your experiments):</p>
<pre><code>&lt;snip&gt;
Starting point
it=0    res=246.4894
it=1    res=83.26919    normstep=0.0558698  btk=1
it=2    res=18.52647    normstep=0.03685367 btk=1
it=3    res=3.472284    normstep=0.01673964 btk=1
it=4    res=3.323951    normstep=0.001436949    btk=1
it=5    res=3.323951    normstep=8.648842e-07   btk=1
&lt;snip&gt;</code></pre>
<p>But are estimated values we obtained are correct? Coinciding simulated and measured curves suggest that yes. To be sure, we can examine <code>tuto_res/tuto.tvar.sim</code> to see that estimated value of <code>r_in</code> net flux is indeed very close to 0.2, the value used in producing simulated data.</p>
</section>
<section id="using-several-random-starting-points" class="level2">
<h2 class="anchored" data-anchor-id="using-several-random-starting-points">Using several random starting points</h2>
<p>In real experiments, with complex networks, it can be helpful to rerun <code>influx_si</code> from different starting points and then select the solution reaching lowest cost value. It can be done using options <code>--irand</code> (use random starting point) and <code>--iseries 1:10</code> (use ten staring points). We add them to <code>commandArgs</code> in <code>tuto.opt</code> file:</p>
<table class="caption-top table">
<colgroup>
<col style="width: 50%">
<col style="width: 50%">
</colgroup>
<tbody>
<tr class="odd">
<td><code>commandArgs</code></td>
<td><code>--noscale --time_order=2 --irand --iseries 1:10 --seed 777</code></td>
</tr>
</tbody>
</table>
<p>In <code>tuto_res/tuto.log</code> we can see how fitting was going for all 10 starting points:</p>
<pre><code>&lt;snip&gt;
Starting point.V01
it=0    res=74.58354
it=1    res=71.92712    normstep=7.216406   btk=1
it=2    res=71.9265 normstep=137091.5   btk=6.169703e-05
it=3    res=71.92648    normstep=9072013    btk=9.323334e-07
it=4    res=71.92648    normstep=105189208  btk=9.323334e-07
it=5    res=71.92648    normstep=105189208  btk=9.323334e-07
it=6    res=71.92648    normstep=105189208  btk=9.323334e-07
it=7    res=71.92648    normstep=105189208  btk=9.323334e-07
it=8    res=71.92648    normstep=105189208  btk=9.323334e-07
it=9    res=71.92648    normstep=105189208  btk=9.323334e-07
it=10   res=71.92648    normstep=105189208  btk=9.323334e-07
it=20   res=71.92648    normstep=105189208  btk=9.323334e-07
it=30   res=71.92648    normstep=105189208  btk=9.323334e-07
it=40   res=71.92648    normstep=105189208  btk=9.323334e-07
it=50   res=71.92648    normstep=105189208  btk=9.323334e-07
***Warning: in first optimization pass in run .V01: nlsic: Maximal non linear iteration number is achieved
Starting point.V02
it=0    res=48.7548
it=1    res=27.55996    normstep=1.002227   btk=1
it=2    res=7.590552    normstep=0.03334867 btk=1
it=3    res=3.328606    normstep=0.006372948    btk=1
it=4    res=3.323951    normstep=0.0002465743   btk=1
it=5    res=3.323951    normstep=2.736581e-07   btk=1
&lt;snip&gt;</code></pre>
<p>Some initial points lead to convergence to the true solution and some others have exhausted the iteration limit (which can be increased, by the way) without reaching a convergence point.</p>
</section>
<section id="conclusion" class="level2">
<h2 class="anchored" data-anchor-id="conclusion">Conclusion</h2>
<p>We have build a simple <em>ab initio</em> network and get to a correct flux estimation. This should facilitate mastering <code>influx_si</code> by novice users. More <code>influx_si</code> features can be found in its documentation <a href="https://influx-si.readthedocs.io/" class="uri">https://influx-si.readthedocs.io/</a></p>
</section>
</section>

</main>
<!-- /main column -->
<script id="quarto-html-after-body" type="application/javascript">
  window.document.addEventListener("DOMContentLoaded", function (event) {
    const icon = "";
    const anchorJS = new window.AnchorJS();
    anchorJS.options = {
      placement: 'right',
      icon: icon
    };
    anchorJS.add('.anchored');
    const isCodeAnnotation = (el) => {
      for (const clz of el.classList) {
        if (clz.startsWith('code-annotation-')) {                     
          return true;
        }
      }
      return false;
    }
    const onCopySuccess = function(e) {
      // button target
      const button = e.trigger;
      // don't keep focus
      button.blur();
      // flash "checked"
      button.classList.add('code-copy-button-checked');
      var currentTitle = button.getAttribute("title");
      button.setAttribute("title", "Copied!");
      let tooltip;
      if (window.bootstrap) {
        button.setAttribute("data-bs-toggle", "tooltip");
        button.setAttribute("data-bs-placement", "left");
        button.setAttribute("data-bs-title", "Copied!");
        tooltip = new bootstrap.Tooltip(button, 
          { trigger: "manual", 
            customClass: "code-copy-button-tooltip",
            offset: [0, -8]});
        tooltip.show();    
      }
      setTimeout(function() {
        if (tooltip) {
          tooltip.hide();
          button.removeAttribute("data-bs-title");
          button.removeAttribute("data-bs-toggle");
          button.removeAttribute("data-bs-placement");
        }
        button.setAttribute("title", currentTitle);
        button.classList.remove('code-copy-button-checked');
      }, 1000);
      // clear code selection
      e.clearSelection();
    }
    const getTextToCopy = function(trigger) {
        const codeEl = trigger.previousElementSibling.cloneNode(true);
        for (const childEl of codeEl.children) {
          if (isCodeAnnotation(childEl)) {
            childEl.remove();
          }
        }
        return codeEl.innerText;
    }
    const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
      text: getTextToCopy
    });
    clipboard.on('success', onCopySuccess);
    if (window.document.getElementById('quarto-embedded-source-code-modal')) {
      const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
        text: getTextToCopy,
        container: window.document.getElementById('quarto-embedded-source-code-modal')
      });
      clipboardModal.on('success', onCopySuccess);
    }
      var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
      var mailtoRegex = new RegExp(/^mailto:/);
        var filterRegex = new RegExp('/' + window.location.host + '/');
      var isInternal = (href) => {
          return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
      }
      // Inspect non-navigation links and adorn them if external
     var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
      for (var i=0; i<links.length; i++) {
        const link = links[i];
        if (!isInternal(link.href)) {
          // undo the damage that might have been done by quarto-nav.js in the case of
          // links that we want to consider external
          if (link.dataset.originalHref !== undefined) {
            link.href = link.dataset.originalHref;
          }
        }
      }
    function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
      const config = {
        allowHTML: true,
        maxWidth: 500,
        delay: 100,
        arrow: false,
        appendTo: function(el) {
            return el.parentElement;
        },
        interactive: true,
        interactiveBorder: 10,
        theme: 'quarto',
        placement: 'bottom-start',
      };
      if (contentFn) {
        config.content = contentFn;
      }
      if (onTriggerFn) {
        config.onTrigger = onTriggerFn;
      }
      if (onUntriggerFn) {
        config.onUntrigger = onUntriggerFn;
      }
      window.tippy(el, config); 
    }
    const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
    for (var i=0; i<noterefs.length; i++) {
      const ref = noterefs[i];
      tippyHover(ref, function() {
        // use id or data attribute instead here
        let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
        try { href = new URL(href).hash; } catch {}
        const id = href.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note) {
          return note.innerHTML;
        } else {
          return "";
        }
      });
    }
    const xrefs = window.document.querySelectorAll('a.quarto-xref');
    const processXRef = (id, note) => {
      // Strip column container classes
      const stripColumnClz = (el) => {
        el.classList.remove("page-full", "page-columns");
        if (el.children) {
          for (const child of el.children) {
            stripColumnClz(child);
          }
        }
      }
      stripColumnClz(note)
      if (id === null || id.startsWith('sec-')) {
        // Special case sections, only their first couple elements
        const container = document.createElement("div");
        if (note.children && note.children.length > 2) {
          container.appendChild(note.children[0].cloneNode(true));
          for (let i = 1; i < note.children.length; i++) {
            const child = note.children[i];
            if (child.tagName === "P" && child.innerText === "") {
              continue;
            } else {
              container.appendChild(child.cloneNode(true));
              break;
            }
          }
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(container);
          }
          return container.innerHTML
        } else {
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(note);
          }
          return note.innerHTML;
        }
      } else {
        // Remove any anchor links if they are present
        const anchorLink = note.querySelector('a.anchorjs-link');
        if (anchorLink) {
          anchorLink.remove();
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        if (note.classList.contains("callout")) {
          return note.outerHTML;
        } else {
          return note.innerHTML;
        }
      }
    }
    for (var i=0; i<xrefs.length; i++) {
      const xref = xrefs[i];
      tippyHover(xref, undefined, function(instance) {
        instance.disable();
        let url = xref.getAttribute('href');
        let hash = undefined; 
        if (url.startsWith('#')) {
          hash = url;
        } else {
          try { hash = new URL(url).hash; } catch {}
        }
        if (hash) {
          const id = hash.replace(/^#\/?/, "");
          const note = window.document.getElementById(id);
          if (note !== null) {
            try {
              const html = processXRef(id, note.cloneNode(true));
              instance.setContent(html);
            } finally {
              instance.enable();
              instance.show();
            }
          } else {
            // See if we can fetch this
            fetch(url.split('#')[0])
            .then(res => res.text())
            .then(html => {
              const parser = new DOMParser();
              const htmlDoc = parser.parseFromString(html, "text/html");
              const note = htmlDoc.getElementById(id);
              if (note !== null) {
                const html = processXRef(id, note);
                instance.setContent(html);
              } 
            }).finally(() => {
              instance.enable();
              instance.show();
            });
          }
        } else {
          // See if we can fetch a full url (with no hash to target)
          // This is a special case and we should probably do some content thinning / targeting
          fetch(url)
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.querySelector('main.content');
            if (note !== null) {
              // This should only happen for chapter cross references
              // (since there is no id in the URL)
              // remove the first header
              if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
                note.children[0].remove();
              }
              const html = processXRef(null, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      }, function(instance) {
      });
    }
        let selectedAnnoteEl;
        const selectorForAnnotation = ( cell, annotation) => {
          let cellAttr = 'data-code-cell="' + cell + '"';
          let lineAttr = 'data-code-annotation="' +  annotation + '"';
          const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
          return selector;
        }
        const selectCodeLines = (annoteEl) => {
          const doc = window.document;
          const targetCell = annoteEl.getAttribute("data-target-cell");
          const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
          const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
          const lines = annoteSpan.getAttribute("data-code-lines").split(",");
          const lineIds = lines.map((line) => {
            return targetCell + "-" + line;
          })
          let top = null;
          let height = null;
          let parent = null;
          if (lineIds.length > 0) {
              //compute the position of the single el (top and bottom and make a div)
              const el = window.document.getElementById(lineIds[0]);
              top = el.offsetTop;
              height = el.offsetHeight;
              parent = el.parentElement.parentElement;
            if (lineIds.length > 1) {
              const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
              const bottom = lastEl.offsetTop + lastEl.offsetHeight;
              height = bottom - top;
            }
            if (top !== null && height !== null && parent !== null) {
              // cook up a div (if necessary) and position it 
              let div = window.document.getElementById("code-annotation-line-highlight");
              if (div === null) {
                div = window.document.createElement("div");
                div.setAttribute("id", "code-annotation-line-highlight");
                div.style.position = 'absolute';
                parent.appendChild(div);
              }
              div.style.top = top - 2 + "px";
              div.style.height = height + 4 + "px";
              div.style.left = 0;
              let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
              if (gutterDiv === null) {
                gutterDiv = window.document.createElement("div");
                gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
                gutterDiv.style.position = 'absolute';
                const codeCell = window.document.getElementById(targetCell);
                const gutter = codeCell.querySelector('.code-annotation-gutter');
                gutter.appendChild(gutterDiv);
              }
              gutterDiv.style.top = top - 2 + "px";
              gutterDiv.style.height = height + 4 + "px";
            }
            selectedAnnoteEl = annoteEl;
          }
        };
        const unselectCodeLines = () => {
          const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
          elementsIds.forEach((elId) => {
            const div = window.document.getElementById(elId);
            if (div) {
              div.remove();
            }
          });
          selectedAnnoteEl = undefined;
        };
          // Handle positioning of the toggle
      window.addEventListener(
        "resize",
        throttle(() => {
          elRect = undefined;
          if (selectedAnnoteEl) {
            selectCodeLines(selectedAnnoteEl);
          }
        }, 10)
      );
      function throttle(fn, ms) {
      let throttle = false;
      let timer;
        return (...args) => {
          if(!throttle) { // first call gets through
              fn.apply(this, args);
              throttle = true;
          } else { // all the others get throttled
              if(timer) clearTimeout(timer); // cancel #2
              timer = setTimeout(() => {
                fn.apply(this, args);
                timer = throttle = false;
              }, ms);
          }
        };
      }
        // Attach click handler to the DT
        const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
        for (const annoteDlNode of annoteDls) {
          annoteDlNode.addEventListener('click', (event) => {
            const clickedEl = event.target;
            if (clickedEl !== selectedAnnoteEl) {
              unselectCodeLines();
              const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
              if (activeEl) {
                activeEl.classList.remove('code-annotation-active');
              }
              selectCodeLines(clickedEl);
              clickedEl.classList.add('code-annotation-active');
            } else {
              // Unselect the line
              unselectCodeLines();
              clickedEl.classList.remove('code-annotation-active');
            }
          });
        }
    const findCites = (el) => {
      const parentEl = el.parentElement;
      if (parentEl) {
        const cites = parentEl.dataset.cites;
        if (cites) {
          return {
            el,
            cites: cites.split(' ')
          };
        } else {
          return findCites(el.parentElement)
        }
      } else {
        return undefined;
      }
    };
    var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
    for (var i=0; i<bibliorefs.length; i++) {
      const ref = bibliorefs[i];
      const citeInfo = findCites(ref);
      if (citeInfo) {
        tippyHover(citeInfo.el, function() {
          var popup = window.document.createElement('div');
          citeInfo.cites.forEach(function(cite) {
            var citeDiv = window.document.createElement('div');
            citeDiv.classList.add('hanging-indent');
            citeDiv.classList.add('csl-entry');
            var biblioDiv = window.document.getElementById('ref-' + cite);
            if (biblioDiv) {
              citeDiv.innerHTML = biblioDiv.innerHTML;
            }
            popup.appendChild(citeDiv);
          });
          return popup.innerHTML;
        });
      }
    }
  });
  </script>
</div> <!-- /content -->




</body></html>